<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>LAZER BLADE 3 - Subzero Theme</title>
    <style>
        @font-face { font-family: 'DATA'; src: url('data.ttf') format('truetype'), local('Courier New'), monospace; font-display: swap; }
        :root { 
            --subzero-dark: #111215; /* Main panel color */
            --subzero-bg: #0a0b0d; /* Body background */
            --subzero-cyan: #00e5ff; /* Main accent color */
            --subzero-text: #b0bec5; /* Secondary text color */
            --accent-magenta: #FF00FF; /* Accent for markers */
        }
        body {
            font-family: 'DATA', monospace; background-color: var(--subzero-bg); color: var(--subzero-text);
            padding: 20px; display: flex; flex-direction: column; align-items: center; min-height: 100vh; margin: 0;
            text-shadow: 0 0 2px rgba(0, 229, 255, 0.5); overflow-x: hidden;
            user-select: none;
        }
        .container { 
            width: 95vw; max-width: 960px; 
            background-color: var(--subzero-dark); 
            border: 2px solid #222327;
            padding: 25px; 
            box-shadow: 0 0 10px rgba(0,0,0,0.8);
            position: relative;
        }
        /* Corner screws based on image */
        .container::before, .container::after {
            content: ''; position: absolute; width: 10px; height: 10px; border-radius: 50%; background: #333; border: 2px solid #222;
        }
        .container::before { top: 5px; left: 5px; } .container::after { top: 5px; right: 5px; }

        #custom-header { 
            font-family: 'DATA', sans-serif; text-align: left; margin-bottom: 25px; 
            font-size: 1.8em; line-height: 1; letter-spacing: 1px; color: var(--subzero-cyan);
            text-transform: uppercase;
        }
        
        #blinking-cursor { animation: blink 1s step-end infinite; color: var(--subzero-cyan); }
        @keyframes blink { from, to { visibility: visible; } 50% { visibility: hidden; } }

        .controls { display: flex; gap: 15px; margin-bottom: 20px; }
        
        button, #fileInputLabel, .toggle-container {
            font-family: 'DATA', monospace; background-color: #1a1b1f; color: var(--subzero-text);
            border: 2px solid #333; padding: 12px 20px; font-size: 14px; cursor: pointer;
            text-transform: uppercase; flex: 1; text-align: center; transition: all 0.2s;
            display: flex; justify-content: center; align-items: center;
            letter-spacing: 1px;
        }
        
        button:hover:not(:disabled), #fileInputLabel:hover, .toggle-container:hover { 
            background-color: #222327; color: var(--subzero-cyan); 
            border-color: var(--subzero-cyan); box-shadow: 0 0 10px rgba(0, 229, 255, 0.3);
        }
        
        button:disabled { opacity: 0.4; cursor: not-allowed; border-color: #222; }
        #loadSampleInput { display: none; }
        
        /* Checkbox Styling */
        input[type="checkbox"] { 
            accent-color: var(--subzero-cyan); margin-right: 10px; 
            transform: scale(1.2); cursor: pointer; 
        }

        .info { 
            background: transparent; padding: 10px 0; 
            border-top: 1px solid #333; border-bottom: 1px solid #333;
            margin-bottom: 10px; font-size: 12px; 
            display: flex; justify-content: space-between; color: var(--subzero-text);
            letter-spacing: 0.5px;
        }
        .info > div > span { color: var(--subzero-cyan); }
        
        .nav-help { font-size: 10px; color: var(--subzero-text); margin-bottom: 5px; text-align: right; width: 100%; opacity: 0.8; letter-spacing: 0.5px; }
        
        #waveformCanvas { 
            width: 100%; height: 300px; 
            background-color: #0a0b0d; 
            border: 2px solid #222327;
            cursor: crosshair; touch-action: none; 
        }
    </style>
</head>
<body>

<div class="container">
    <div id="custom-header">LAZER_BLADE_3 // SUBZERO<span id="blinking-cursor">_</span></div>
    
    <div class="controls">
        <label id="fileInputLabel" for="loadSampleInput">INGEST_FILE</label>
        <input type="file" id="loadSampleInput" accept="audio/*">
        
        <button id="loadSampleButton" disabled>PLAY_LOOP</button>
        <button id="exportTrimButton" disabled>EXPORT_WAV</button>
    </div>

    <div class="info">
        <div>STATUS: <span id="status">READY: AMEN.WAV</span></div>
        <div>WINDOW: <span id="loopRangeDisplay">0.000S >> 6.000S</span></div>
        <div>ZOOM: <span id="zoomMag">8X</span> | AMP: <span id="ampMag">1.0X</span></div>
    </div>
    
    <div class="nav-help">CTRL+UP/DN: ZOOM | SHIFT+UP/DN: GAIN | SCROLL: PAN</div>
    <canvas id="waveformCanvas"></canvas>
    <label class="toggle-container" style="margin-top:10px; border: none; background: none; justify-content: flex-start; padding: 0; font-size: 12px; color: var(--subzero-text);">
        <input type="checkbox" id="snapToggle" checked style="transform: scale(1); margin-right: 5px;"> SNAP_ZERO
    </label>
</div>

<script>
    // --- GLOBAL STATE ---
    let audioCtx, audioBuf, sourceNode = null;
    let loopStart = 0, loopEnd = 0;
    let isPlaying = false, isDragging = false, dragTarget = null;
    let zoomH = 1, scrollPos = 0, ampZoom = 1;
    let mouseX = 0, playbackStartTime = 0, aniFrame = null;

    // --- DOM ELEMENTS ---
    const canvas = document.getElementById('waveformCanvas');
    const ctx = canvas.getContext('2d');
    const status = document.getElementById('status');
    const loopDisp = document.getElementById('loopRangeDisplay');
    const zoomMagDisp = document.getElementById('zoomMag');
    const ampMagDisp = document.getElementById('ampMag');
    const input = document.getElementById('loadSampleInput');
    const btnPlay = document.getElementById('loadSampleButton');
    const btnExport = document.getElementById('exportTrimButton');
    const snapToggle = document.getElementById('snapToggle');

    // --- AUDIO ENGINE ---
    function getAudioContext() {
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        return audioCtx;
    }

    function startAudio(offset = 0) {
        if (!audioBuf) return;
        getAudioContext();
        if (sourceNode) { sourceNode.stop(); sourceNode.disconnect(); }
        sourceNode = audioCtx.createBufferSource();
        sourceNode.buffer = audioBuf;
        sourceNode.loop = true;
        sourceNode.loopStart = loopStart;
        sourceNode.loopEnd = loopEnd;
        sourceNode.connect(audioCtx.destination);
        let startPoint = offset;
        if (startPoint < loopStart || startPoint > loopEnd) startPoint = loopStart;
        sourceNode.start(0, startPoint);
        playbackStartTime = audioCtx.currentTime - (startPoint - loopStart);
        isPlaying = true;
        btnPlay.textContent = "STOP_ENGINE";
        btnPlay.style.borderColor = "var(--subzero-cyan)";
        renderLoop();
    }

    function stopAudio() {
        if (sourceNode) { sourceNode.stop(); sourceNode = null; }
        isPlaying = false;
        btnPlay.textContent = "PLAY_LOOP";
        btnPlay.style.borderColor = "";
        cancelAnimationFrame(aniFrame);
    }

    function togglePlay() {
        if (isPlaying) { stopAudio(); draw(); } else { startAudio(loopStart); }
    }

    function syncLoopPoints() {
        if (sourceNode && isPlaying) {
            sourceNode.loopStart = loopStart;
            sourceNode.loopEnd = loopEnd;
        }
    }

    function findZeroCrossing(time) {
        if (!audioBuf) return time;
        const data = audioBuf.getChannelData(0);
        const centerIdx = Math.floor(time * audioBuf.sampleRate);
        const range = 500;
        let bestIdx = centerIdx, minAmp = 1.0;
        for (let i = centerIdx - range; i < centerIdx + range; i++) {
            if (i >= 0 && i < data.length) {
                const absVal = Math.abs(data[i]);
                if (absVal < minAmp) { minAmp = absVal; bestIdx = i; }
            }
        }
        return bestIdx / audioBuf.sampleRate;
    }

    // --- VISUALIZATION HELPERS ---
    function getVisibleData() {
        if (!audioBuf) return { startSmp: 0, visibleSamples: 0 };
        const visibleSamples = audioBuf.length / zoomH;
        const scrollable = audioBuf.length - visibleSamples;
        const startSmp = scrollPos * scrollable;
        return { startSmp, visibleSamples };
    }

    function xToTime(x) {
        const { startSmp, visibleSamples } = getVisibleData();
        return ((x / canvas.width) * visibleSamples + startSmp) / audioBuf.sampleRate;
    }

    function timeToX(t) {
        const { startSmp, visibleSamples } = getVisibleData();
        return (((t * audioBuf.sampleRate) - startSmp) / visibleSamples) * canvas.width;
    }

    // --- INTERACTION EVENT LISTENERS ---
    canvas.onwheel = (e) => {
        if (!audioBuf) return;
        e.preventDefault();
        if (e.shiftKey) {
            const step = (e.deltaY * 0.0005) / zoomH * 10;
            scrollPos = Math.max(0, Math.min(1, scrollPos + step));
        } else {
            const focalTime = xToTime(e.offsetX);
            const zoomFactor = e.deltaY > 0 ? 0.85 : 1.15;
            zoomH = Math.max(1, Math.min(50000, zoomH * zoomFactor));
            const newVisible = audioBuf.length / zoomH;
            const newStartSmp = (focalTime * audioBuf.sampleRate) - (e.offsetX / canvas.width) * newVisible;
            const maxScroll = audioBuf.length - newVisible;
            scrollPos = maxScroll <= 0 ? 0 : Math.max(0, Math.min(1, newStartSmp / maxScroll));
        }
        draw(); updateUI();
    };

    canvas.onmousedown = (e) => {
        if (!audioBuf) return;
        let time = xToTime(e.offsetX);
        if (snapToggle.checked) time = findZeroCrossing(time);
        const tol = (20 / canvas.width) * (audioBuf.length / zoomH / audioBuf.sampleRate);
        if (Math.abs(time - loopStart) < tol) { dragTarget = 'start'; }
        else if (Math.abs(time - loopEnd) < tol) { dragTarget = 'end'; }
        else {
            loopStart = time; loopEnd = time + 0.05; dragTarget = 'end';
            if (isPlaying) { stopAudio(); startAudio(loopStart); }
        }
        isDragging = true;
    };

    window.onmousemove = (e) => {
        if (!isDragging || !audioBuf) return;
        const rect = canvas.getBoundingClientRect();
        const rawX = e.clientX - rect.left;
        let time = Math.max(0, Math.min(audioBuf.duration, xToTime(rawX)));
        if (snapToggle.checked) time = findZeroCrossing(time);
        if (dragTarget === 'start') { loopStart = Math.min(time, loopEnd - 0.001); }
        else if (dragTarget === 'end') { loopEnd = Math.max(time, loopStart + 0.001); }
        syncLoopPoints(); draw(); updateUI();
    };

    window.onmouseup = () => { isDragging = false; dragTarget = null; draw(); };

    // --- DRAWING LOOP ---
    function draw(now = null) {
        const w = canvas.width, h = canvas.height;
        ctx.fillStyle = '#0a0b0d'; ctx.fillRect(0,0,w,h);
        if (!audioBuf) return;
        const data = audioBuf.getChannelData(0);
        const { startSmp, visibleSamples } = getVisibleData();
        const step = Math.max(1, visibleSamples / w);
        ctx.beginPath(); ctx.strokeStyle = '#00e5ff'; ctx.lineWidth = 1;
        for (let i = 0; i < w; i++) {
            const b = Math.floor(startSmp + (i * step));
            if (b >= data.length) break;
            let min = 1.0, max = -1.0;
            for(let j=0; j<step; j++) {
                const v = data[b+j] || 0; if(v<min) min=v; if(v>max) max=v;
            }
            const yMin = (1 + min * ampZoom) * h / 2;
            const yMax = (1 + max * ampZoom) * h / 2;
            ctx.moveTo(i, yMin); ctx.lineTo(i, yMax);
        }
        ctx.stroke();
        const sX = timeToX(loopStart), eX = timeToX(loopEnd);
        ctx.fillStyle = 'rgba(0, 229, 255, 0.1)'; ctx.fillRect(sX, 0, eX - sX, h);
        ctx.strokeStyle = '#00e5ff'; ctx.strokeRect(sX, 0, 1, h);
        ctx.fillStyle = '#00e5ff'; ctx.fillRect(sX-5, 0, 10, 12);
        ctx.strokeStyle = '#FF00FF'; ctx.strokeRect(eX, 0, 1, h);
        ctx.fillStyle = '#FF00FF'; ctx.fillRect(eX-5, h-12, 10, 12);
        if (now !== null) {
            const pX = timeToX(now);
            if (pX >= 0 && pX <= w) {
                ctx.strokeStyle = '#FF00FF'; ctx.lineWidth = 2; ctx.beginPath();
                ctx.moveTo(pX, 0); ctx.lineTo(pX, h); ctx.stroke();
            }
        }
    }

    function renderLoop() {
        if (!isPlaying) return;
        const dur = loopEnd - loopStart;
        if (dur <= 0) return;
        let playTime = loopStart + (audioCtx.currentTime - playbackStartTime) % dur;
        draw(playTime);
        aniFrame = requestAnimationFrame(renderLoop);
    }

    function updateUI() {
        if (!audioBuf) return;
        loopDisp.textContent = `${loopStart.toFixed(3)}S >> ${loopEnd.toFixed(3)}S`;
        zoomMagDisp.textContent = `${Math.round(zoomH)}X`;
        ampMagDisp.textContent = `${ampZoom.toFixed(1)}X`;
    }

    // --- FILE HANDLING & EXPORT ---
    async function handleFile(e) {
        const file = e.target.files[0]; if (!file) return;
        getAudioContext(); status.textContent = 'SCANNING...';
        try {
            const ab = await file.arrayBuffer();
            audioBuf = await audioCtx.decodeAudioData(ab);
            loopStart = 0; loopEnd = audioBuf.duration;
            zoomH = 1; scrollPos = 0;
            status.textContent = `READY: ${file.name.toUpperCase()}`;
            btnPlay.disabled = false; btnExport.disabled = false;
            updateUI(); draw();
        } catch (err) { status.textContent = "ERR: FILE_CORRUPT"; }
    }

    function encodeWAV(buf) {
        let n = buf.numberOfChannels, sr = buf.sampleRate, len = buf.length * n * 2 + 44;
        let ab = new ArrayBuffer(len), view = new DataView(ab), pos = 0;
        const s = (str) => { for(let i=0; i<str.length; i++) view.setUint8(pos++, str.charCodeAt(i)); };
        s('RIFF'); view.setUint32(pos, len-8, true); pos+=4; s('WAVEfmt '); view.setUint32(pos, 16, true); pos+=4;
        view.setUint16(pos, 1, true); pos+=2; view.setUint16(pos, n, true); pos+=2; view.setUint32(pos, sr, true); pos+=4;
        view.setUint32(pos, sr*n*2, true); pos+=4; view.setUint16(pos, n*2, true); pos+=2; view.setUint16(pos, 16, true); pos+=2;
        s('data'); view.setUint32(pos, len-pos-4, true); pos+=4;
        for(let i=0; i<buf.length; i++) { for(let c=0; c<n; c++) { let v = Math.max(-1, Math.min(1, buf.getChannelData(c)[i])); view.setInt16(pos, v < 0 ? v * 0x8000 : v * 0x7FFF, true); pos+=2; } }
        return ab;
    }

    btnExport.onclick = () => {
        if (!audioBuf) return;
        const sSmp = Math.floor(loopStart * audioBuf.sampleRate), eSmp = Math.floor(loopEnd * audioBuf.sampleRate);
        const len = eSmp - sSmp;
        if (len <= 0) return;
        const nBuf = audioCtx.createBuffer(audioBuf.numberOfChannels, len, audioBuf.sampleRate);
        for(let c=0; c<audioBuf.numberOfChannels; c++) { nBuf.getChannelData(c).set(audioBuf.getChannelData(c).subarray(sSmp, eSmp)); }
        const wav = encodeWAV(nBuf);
        const a = document.createElement('a'); a.href = URL.createObjectURL(new Blob([wav], {type:'audio/wav'}));
        a.download = `LB3_${Date.now()}.wav`; a.click();
    };

    input.onchange = handleFile;
    btnPlay.onclick = togglePlay;
    window.onload = () => { canvas.width = canvas.clientWidth; canvas.height = canvas.clientHeight; draw(); };
    window.onresize = () => { canvas.width = canvas.clientWidth; canvas.height = canvas.clientHeight; draw(); };
</script>
</body>
</html>
